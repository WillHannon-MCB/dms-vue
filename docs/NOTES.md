# Notes

## Overview

_Rebuild dms-viz with these features:_

1. Focus on the protein viewer. The protein viewer is the center of the application, so leave room for as much customization as possible.
2. Handle UI and reactivity with Vue.
3. Store the application's state in a central ‘store’ and subscribe all elements to this ‘store’.

## Inputs

Format of input data

### Required

- Model ID(s): Unique IDs for protein models that the data corresponds to (i.e. PDB ID)
- Chain ID(s): Which chains do the residue numberings correspond with
- Residue IDs: The ID of the residue in the model (protein site)
- Residue-level data:
  - Quantitative: summary of mutation-level data (i.e. mean mutation effect)
  - Quantitative: no associated mutation-level data (i.e. solvent accessible surface)
  - Categorical: non-numerical information (i.e. protein annotations)

### Conditionally Required

- Condition: Unique ID if there is more than one residue-level data point per residue ID

### Optional

- Wildtype: The ‘wildtype’ state of the amino acid at a site. Useful for validation.
- Configuration: Columns that configure on a per-element level (i.e. axis labels)
- Mutation: The ‘mutant’ amino acid associated with mutation-level data
- Mutation-level data:
  - Quantitative (mutation effect)

## Workflow

There are two ways to use the application:

### Manual

1. Upload CSV data with the information described above
2. Configure the application in one of two ways
   - Fill out a form-based UI
   - Provide a config file (also generated by i.)
3. Interact with the application
4. Save the state of the application as a zip file

### Automatic

1. Provide the application with a previously generated state that’s being hosted remotely through a URL by uploading it manually.

## Interaction

This is tentative while I work out the details

User interaction happens through the form (the configuration file) or the UI elements (protein and plots). The plot and protein talk to one another, so selecting a residue in the protein structure or plots will update the whole application.

## State

This is tentative while I work out the details

A central ‘store’ will handle most of the application's state, including details like configuration and selected residues. All elements of the application will subscribe to the store for updates. By necessity, Mol\*’s internal state management will handle the protein’s state.

The application’s current state can be downloaded as a zip file containing the data, the updated configuration, and the protein’s state.

## Motivation

I better understand the limitations of dms-viz. These limitations fall into two categories:

- Missing features that lead people to use tailored software like Chimera and Altair
- Bottlenecks in the workflow that make it hard to use

There are two reasons why I think I can address these now:

**First**, I better understand web development. I built dms-viz like Sarah and John’s dms-view but with certain organizational improvements:

- UI elements are bundled into classes and rendering is handled separately from updates.
- The state is managed somewhat centrally in a State object.

However, this approach has massive drawbacks in terms of managing complexity. Most (maybe all) modern web applications of moderate complexity are now built with ‘frameworks’ (like Vue). These have three massive advantages:

- Code is organized into discrete ‘components’ that bundle HTML markdown, CSS style, and JavaScript logic into a single file.
- ‘Reactivity’—how changes are made as a result of interaction—is abstracted away to the framework.
- The state can be managed through a central ‘store’ object that works nicely with the framework’s reactivity model.

The bottom line is that frameworks make applications faster to build, easier to maintain, and possible to scale. I didn’t understand web development enough to use a framework like Vue for dms-viz. Now I’ve built several websites with Vue.

**Second**, there have been massive improvements in web-based molecular visualization software over something like NGL. Specifically, Mol*was created by the people who made NGL and Jsmol to rival Chimera and PyMol in their utility and customizability. You can use Mol* to make publication-quality figures on the web. The main advantage that Mol\* has over NGL is that it comes with its own UI and State management. That means I don’t need to worry about managing the protein in my application. I only need to worry about formatting the data, making a color scale, and listening to interactions with residues.

## Status

### Code Organization

```bash
src
├── App.vue
├── assets
│   ├── css
│   │   ├── base.css
│   │   └── main.css
│   ├── data
│   │   └── residueData.json
│   └── images
│       └── logo.svg
├── components
│   └── icons
│       └── IconDocumentation.vue
├── main.js
├── protein
│   └── ProteinViewer.vue
├── stores
│   ├── color.js
│   ├── config.js
│   └── data.js
├── upload
│   └── UploadCSV.vue
└── utils
    ├── data
    │   └── process-input-data.js
    ├── molstar
    │   ├── custom-element.js
    │   └── viewer-config.js
    └── scales
        └── color-scales.js
```

### Data flow

1. Users upload a CSV to the `UploadCSV.vue` component. The raw data gets added to the store `data.js`.

```js
export const useDataStore = defineStore('data', {
  state: () => ({
    rawData: null,
    successMessage: '',
    errorMessage: '',
  }),

  actions: {
    async uploadData(csvText, fileName = null) {
      try {
        console.log(fileName)
        // Parse the CSV data
        const parsedData = parseCsvData(csvText)
        // Update the store with valid data
        this.rawData = parsedData
        console.log('Data uploaded and validated:', this.rawData)
        this.successMessage = fileName
          ? `File "${fileName}" uploaded and validated successfully!`
          : 'Data uploaded and validated successfully!'
        this.errorMessage = ''
      } catch (error) {
        this.rawData = null
        this.successMessage = ''
        this.errorMessage = `Error processing CSV: ${error.message}`
        throw error
      }
    },
  },

  getters: {
    models(state) {
      if (!state.rawData) return []
      const models = state.rawData.flatMap((row) => row.model.split(':'))
      return Array.from(new Set(models))
    },
    structures() {
      return this.models.map((model) => ({
        url: `https://www.ebi.ac.uk/pdbe/static/entry/${model.toLowerCase()}_updated.cif`,
        format: 'mmcif',
        assemblyId: '1',
        isBinary: false,
      }))
    },
    conditions(state) {
      if (!state.rawData || !state.rawData[0]?.condition) {
        return []
      }
      return Array.from(new Set(state.rawData.map((row) => row.condition)))
    },
  },
})
```

2. The data is parsed and validated with functions from `utils/data/process-input-data.js`.

3. Eventually, the raw data will configure a UI component called `ui/config/ConfigureViewer.vue` or something like that. Those choices will populate the store `config.js`. For now, I'm hard-coding values based on the dataset I'm testing with.

```js
import { defineStore } from 'pinia'

export const useConfigStore = defineStore('config', {
  state: () => ({
    residueColumns: ['max_mut_escape'], // Hardcoded example columns
  }),

  getters: {
    selectedResidueColumns(state) {
      return state.residueColumns
    },
  },
})
```

4. After the data's been upload and configuration setting have been chosen, the application makes color schemes (molstar CustomElementProperties) for the protein models. Those are stored in `color.js`:

```js
export const useColorStore = defineStore('color', {
  state: () => ({
    customElements: {},
  }),

  actions: {
    generateCustomElements() {
      const dataStore = useDataStore()
      const configStore = useConfigStore()

      if (!dataStore.rawData || !configStore.residueColumns.length) {
        console.warn('Data or configuration is missing. Cannot generate custom elements.')
        return
      }

      // Access raw (non-proxy) data
      const rawData = toRaw(dataStore.rawData)

      const residueColumns = configStore.residueColumns
      const conditions = dataStore.conditions.length ? dataStore.conditions : [null]

      residueColumns.forEach((column) => {
        conditions.forEach((condition) => {
          const key = condition ? `${condition}-${column}` : column
          console.log('Generating custom element:', key)

          const customElement = createCustomResidueColoring(column, condition, rawData)
          this.customElements[key] = customElement
        })
      })
    },
  },
})
```

I have a simple factory function for making these color objects in `utils/molstar/custom-element.js`:

```js
/**
 * Factory function to create a CustomElementProperty for Mol*.
 *
 * @param {string} column - The metric column to aggregate.
 * @param {string} [condition] - The condition column to filter on (optional).
 * @param {Array} rawData - The input raw data array.
 * @returns {CustomElementProperty} - A configured CustomElementProperty.
 */
export function createCustomResidueColoring(column, condition, rawData) {
  if (!rawData || !column) {
    throw new Error('Both rawData and column are required.')
  }

  // Process residue data for the given column and condition
  const processedData = processResidueData(rawData, column, condition)

  // Generate a color scale based on the processed data
  const residueColorScale = generateSequentialColorScale(processedData, 'value')

  return CustomElementProperty.create({
    label: `${column}${condition ? ` for ${condition}` : ''}`,
    name: `${condition ? `${condition}-${column}` : column}`,
    async getData(model) {
      const residueColorMap = new Map()

      // Map processed data for quick lookup
      const dataMap = processedData.reduce((map, entry) => {
        const key = `${entry.chain}:${entry.residue}`
        map.set(key, entry.value)
        return map
      }, new Map())

      const { _rowCount: residueCount } = model.atomicHierarchy.residues
      const { offsets: residueOffsets } = model.atomicHierarchy.residueAtomSegments
      const chainIndex = model.atomicHierarchy.chainAtomSegments.index

      for (let rI = 0; rI < residueCount; rI++) {
        const cI = chainIndex[residueOffsets[rI]]
        const key = `${model.atomicHierarchy.chains.auth_asym_id.value(cI)}:${model.atomicHierarchy.residues.auth_seq_id.value(rI)}`

        if (!dataMap.has(key)) continue
        const ann = dataMap.get(key)

        for (let aI = residueOffsets[rI]; aI < residueOffsets[rI + 1]; aI++) {
          residueColorMap.set(aI, ann)
        }
      }
      console.log(residueColorMap)
      return { value: residueColorMap }
    },
    coloring: {
      getColor(value) {
        // Use the custom color scale based on the provided column
        console.log(value)
        console.log(residueColorScale(value))
        return Color.fromHexStyle(residueColorScale(value))
      },
      defaultColor: Color(0x777777), // Default color for residues without data
    },
    getLabel(value) {
      return `${column} Score: ${value}`
    },
  })
}
```
