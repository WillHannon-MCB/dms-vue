# Notes

## Overview

_Rebuild dms-viz with these features:_

1. Focus on the protein viewer. The protein viewer is the center of the application, so leave room for as much customization as possible.
2. Handle UI and reactivity with Vue.
3. Store the application's state in a central ‘store’ and subscribe all elements to this ‘store’.

## Inputs

Format of input data

### Required

- Model ID(s): Unique IDs for protein models that the data corresponds to (i.e. PDB ID)
- Chain ID(s): Which chains do the residue numberings correspond with
- Residue IDs: The ID of the residue in the model (protein site)
- Residue-level data:
  - Quantitative: summary of mutation-level data (i.e. mean mutation effect)
  - Quantitative: no associated mutation-level data (i.e. solvent accessible surface)
  - Categorical: non-numerical information (i.e. protein annotations)

### Conditionally Required

- Condition: Unique ID if there is more than one residue-level data point per residue ID

### Optional

- Wildtype: The ‘wildtype’ state of the amino acid at a site. Useful for validation.
- Configuration: Columns that configure on a per-element level (i.e. axis labels)
- Mutation: The ‘mutant’ amino acid associated with mutation-level data
- Mutation-level data:
  - Quantitative (mutation effect)

## Workflow

There are two ways to use the application:

### Manual

1. Upload CSV data with the information described above
2. Configure the application in one of two ways
   - Fill out a form-based UI
   - Provide a config file (also generated by i.)
3. Interact with the application
4. Save the state of the application as a zip file

### Automatic

1. Provide the application with a previously generated state that’s being hosted remotely through a URL by uploading it manually.

## Interaction

This is tentative while I work out the details

User interaction happens through the form (the configuration file) or the UI elements (protein and plots). The plot and protein talk to one another, so selecting a residue in the protein structure or plots will update the whole application.

## State

This is tentative while I work out the details

A central ‘store’ will handle most of the application's state, including details like configuration and selected residues. All elements of the application will subscribe to the store for updates. By necessity, Mol\*’s internal state management will handle the protein’s state.

The application’s current state can be downloaded as a zip file containing the data, the updated configuration, and the protein’s state.

## Motivation

I better understand the limitations of dms-viz. These limitations fall into two categories:

- Missing features that lead people to use tailored software like Chimera and Altair
- Bottlenecks in the workflow that make it hard to use

There are two reasons why I think I can address these now:

**First**, I better understand web development. I built dms-viz like Sarah and John’s dms-view but with certain organizational improvements:

- UI elements are bundled into classes and rendering is handled separately from updates.
- The state is managed somewhat centrally in a State object.

However, this approach has massive drawbacks in terms of managing complexity. Most (maybe all) modern web applications of moderate complexity are now built with ‘frameworks’ (like Vue). These have three massive advantages:

- Code is organized into discrete ‘components’ that bundle HTML markdown, CSS style, and JavaScript logic into a single file.
- ‘Reactivity’—how changes are made as a result of interaction—is abstracted away to the framework.
- The state can be managed through a central ‘store’ object that works nicely with the framework’s reactivity model.

The bottom line is that frameworks make applications faster to build, easier to maintain, and possible to scale. I didn’t understand web development enough to use a framework like Vue for dms-viz. Now I’ve built several websites with Vue.

**Second**, there have been massive improvements in web-based molecular visualization software over something like NGL. Specifically, Mol*was created by the people who made NGL and Jsmol to rival Chimera and PyMol in their utility and customizability. You can use Mol* to make publication-quality figures on the web. The main advantage that Mol\* has over NGL is that it comes with its own UI and State management. That means I don’t need to worry about managing the protein in my application. I only need to worry about formatting the data, making a color scale, and listening to interactions with residues.
